import express, { type Express, type Request, type Response, type NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import multer from "multer";
import path from "path";
import { fileURLToPath } from "url";
import { insertUserSchema, insertTicketSchema, insertSubscriptionSchema, insertProductSchema, insertWhatsappSettingsSchema, insertSentMessageSchema, insertReceivedMessageSchema, insertAiTokenSettingsSchema, insertUserSubscriptionSchema, type User } from "@shared/schema";
import { z } from "zod";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// JWT secret initialization
import crypto from 'crypto';

let jwtSecret: string;
if (process.env.JWT_SECRET) {
  jwtSecret = process.env.JWT_SECRET;
} else {
  if (process.env.NODE_ENV === 'production') {
    console.error("ğŸ›‘ JWT_SECRET environment variable is required in production!");
    console.error("ğŸ’¡ Set JWT_SECRET to a random 32+ character string");
    process.exit(1);
  } else {
    console.warn("ğŸ”§ DEV MODE: Using temporary random JWT secret - set JWT_SECRET env var");
    jwtSecret = crypto.randomBytes(32).toString('hex');
  }
}

// Multer configuration for file uploads
const storage_config = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.join(__dirname, "../uploads"));
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage: storage_config,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: (req: any, file: any, cb: any) => {
    const allowedTypes = ["image/jpeg", "image/png", "image/gif", "image/webp"];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Ù†ÙˆØ¹ ÙØ§ÛŒÙ„ Ù…Ø¬Ø§Ø² Ù†ÛŒØ³Øª"));
    }
  },
});

// Auth middleware  
interface AuthRequest extends Request {
  user?: User;
}

const authenticateToken = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ message: "ØªÙˆÚ©Ù† Ø§Ø­Ø±Ø§Ø² Ù‡ÙˆÛŒØª Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
  }

  try {
    const decoded = jwt.verify(token, jwtSecret) as { userId: string };
    const user = await storage.getUser(decoded.userId);
    if (!user) {
      return res.status(401).json({ message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
    }
    req.user = user;
    next();
  } catch (error) {
    return res.status(403).json({ message: "ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª" });
  }
};

// Admin middleware
const requireAdmin = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (req.user?.role !== "admin") {
    return res.status(403).json({ message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¯ÛŒØ± Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
  }
  next();
};

// Admin or Level 1 user middleware for WhatsApp access
const requireAdminOrLevel1 = (req: AuthRequest, res: Response, next: NextFunction) => {
  if (req.user?.role !== "admin" && req.user?.role !== "user_level_1") {
    return res.status(403).json({ message: "Ø¯Ø³ØªØ±Ø³ÛŒ Ù…Ø¯ÛŒØ± ÛŒØ§ Ú©Ø§Ø±Ø¨Ø± Ø³Ø·Ø­ Û± Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
  }
  next();
};

export async function registerRoutes(app: Express): Promise<Server> {
  // Auth routes
  app.post("/api/auth/register", async (req, res) => {
    try {
      // Generate username from email if not provided
      const userData = {
        ...req.body,
        username: req.body.username || req.body.email.split('@')[0] + Math.random().toString(36).substr(2, 4)
      };
      
      const validatedData = insertUserSchema.parse(userData);
      
      // Check if user already exists
      const existingUser = await storage.getUserByEmail(validatedData.email);
      if (existingUser) {
        return res.status(400).json({ message: "Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ù†Ø§Ù… Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(validatedData.password!, 10);
      
      const user = await storage.createUser({
        ...validatedData,
        password: hashedPassword,
      });

      // Create 7-day free trial subscription for new users
      try {
        // Find the default free subscription plan
        let trialSubscription = (await storage.getAllSubscriptions()).find(sub => 
          sub.isDefault === true
        );

        // If no default subscription exists, this should not happen
        // The system should have created a default subscription during initialization
        if (!trialSubscription) {
          console.warn("âš ï¸ Default subscription not found - this should not happen");
          console.warn("Continuing without creating subscription for user:", user.id);
        } else {
          // Create user subscription for 7-day trial
          await storage.createUserSubscription({
            userId: user.id,
            subscriptionId: trialSubscription.id,
            remainingDays: 7,
            startDate: new Date(),
            endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
            status: "active",
            isTrialPeriod: true,
          });
          console.log("âœ… Created 7-day trial subscription for registered user:", user.id);
        }
      } catch (trialError) {
        console.error("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú© Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ:", trialError);
        // Don't fail user registration if trial subscription creation fails
      }

      // Generate JWT
      const token = jwt.sign({ userId: user.id }, jwtSecret, { expiresIn: "7d" });

      res.json({ 
        user: { ...user, password: undefined },
        token 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      
      const user = await storage.getUserByEmailOrUsername(email);
      if (!user || !user.password) {
        return res.status(401).json({ message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ/Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" });
      }

      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        return res.status(401).json({ message: "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ/Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª" });
      }

      const token = jwt.sign({ userId: user.id }, jwtSecret, { expiresIn: "7d" });

      res.json({ 
        user: { ...user, password: undefined },
        token 
      });
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± ÙˆØ±ÙˆØ¯ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  app.get("/api/auth/me", authenticateToken, async (req: AuthRequest, res) => {
    res.json({ user: { ...req.user!, password: undefined } });
  });

  // User management routes (Admin only)
  app.get("/api/users", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      
      // Get subscription data for each user
      const usersWithSubscriptions = await Promise.all(
        users.map(async (user) => {
          try {
            // Get user's active subscription
            const userSubscription = await storage.getUserSubscription(user.id);
            
            let subscriptionInfo = null;
            if (userSubscription) {
              // Get subscription details
              const subscription = await storage.getSubscription(userSubscription.subscriptionId);
              subscriptionInfo = {
                name: subscription?.name || 'Ù†Ø§Ù…Ø´Ø®Øµ',
                remainingDays: userSubscription.remainingDays,
                status: userSubscription.status,
                isTrialPeriod: userSubscription.isTrialPeriod
              };
            }
            
            return {
              ...user,
              password: undefined,
              subscription: subscriptionInfo
            };
          } catch (error) {
            // If there's an error getting subscription data, return user without subscription
            return {
              ...user,
              password: undefined,
              subscription: null
            };
          }
        })
      );
      
      res.json(usersWithSubscriptions);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†" });
    }
  });

  app.post("/api/users", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const validatedData = insertUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingEmailUser = await storage.getUserByEmail(validatedData.email);
      if (existingEmailUser) {
        return res.status(400).json({ message: "Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ø§ÛŒÙ…ÛŒÙ„ Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ù†Ø§Ù… Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª" });
      }

      const existingUsernameUser = await storage.getUserByUsername(validatedData.username!);
      if (existingUsernameUser) {
        return res.status(400).json({ message: "Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ Ù‚Ø¨Ù„Ø§Ù‹ Ø«Ø¨Øª Ù†Ø§Ù… Ú©Ø±Ø¯Ù‡ Ø§Ø³Øª" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(validatedData.password!, 10);
      
      const user = await storage.createUser({
        ...validatedData,
        password: hashedPassword,
      });

      // Create 7-day free trial subscription for new users created by admin
      try {
        // Find the default free subscription plan
        let trialSubscription = (await storage.getAllSubscriptions()).find(sub => 
          sub.isDefault === true
        );

        // If no default subscription exists, this should not happen
        // The system should have created a default subscription during initialization
        if (!trialSubscription) {
          console.warn("âš ï¸ Default subscription not found - this should not happen");
          console.warn("Continuing without creating subscription for user:", user.id);
        } else {
          // Create user subscription for 7-day trial
          await storage.createUserSubscription({
            userId: user.id,
            subscriptionId: trialSubscription.id,
            remainingDays: 7,
            startDate: new Date(),
            endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now
            status: "active",
            isTrialPeriod: true,
          });
          console.log("âœ… Created 7-day trial subscription for admin-created user:", user.id);
        }
      } catch (trialError) {
        console.error("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú© Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ:", trialError);
        // Don't fail user creation if trial subscription creation fails
      }

      res.json({ ...user, password: undefined });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  app.put("/api/users/:id", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const user = await storage.updateUser(id, updates);
      if (!user) {
        return res.status(404).json({ message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({ ...user, password: undefined });
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  app.delete("/api/users/:id", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Check if user exists
      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ message: "Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      // First delete user subscriptions (to avoid foreign key constraint)
      // Get ALL user subscriptions for this specific user
      const userSubscriptions = await storage.getUserSubscriptionsByUserId(id);
      for (const subscription of userSubscriptions) {
        await storage.deleteUserSubscription(subscription.id);
      }

      // Delete user tickets (if any)
      const userTickets = await storage.getTicketsByUser(id);
      for (const ticket of userTickets) {
        await storage.deleteTicket(ticket.id);
      }

      // Delete user products (if any)
      const userProducts = await storage.getProductsByUser(id);
      for (const product of userProducts) {
        await storage.deleteProduct(product.id);
      }

      // Finally delete the user
      const success = await storage.deleteUser(id);
      
      if (!success) {
        return res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±" });
      }

      res.json({ message: "Ú©Ø§Ø±Ø¨Ø± Ùˆ ØªÙ…Ø§Ù… Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…Ø±Ø¨ÙˆØ·Ù‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±:", error);
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Profile routes
  app.put("/api/profile", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const { firstName, lastName } = req.body;
      const user = await storage.updateUser(req.user!.id, { firstName, lastName });
      
      res.json({ ...user!, password: undefined });
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù¾Ø±ÙˆÙØ§ÛŒÙ„" });
    }
  });

  app.post("/api/profile/picture", authenticateToken, upload.single("profilePicture"), async (req: AuthRequest, res) => {
    try {
      if (!(req as any).file) {
        return res.status(400).json({ message: "ÙØ§ÛŒÙ„ ØªØµÙˆÛŒØ± Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }

      const profilePicture = `/uploads/${(req as any).file.filename}`;
      const user = await storage.updateUser(req.user!.id, { profilePicture });
      
      res.json({ ...user!, password: undefined });
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ± Ù¾Ø±ÙˆÙØ§ÛŒÙ„" });
    }
  });

  // Ticket routes
  app.get("/api/tickets", authenticateToken, async (req: AuthRequest, res) => {
    try {
      let tickets;
      if (req.user!.role === "admin") {
        tickets = await storage.getAllTickets();
      } else {
        tickets = await storage.getTicketsByUser(req.user!.id);
      }
      res.json(tickets);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÛŒÚ©Øª Ù‡Ø§" });
    }
  });

  app.post("/api/tickets", authenticateToken, upload.array("attachments", 5), async (req: AuthRequest, res) => {
    try {
      const validatedData = insertTicketSchema.parse({
        ...req.body,
        userId: req.user!.id,
        attachments: (req as any).files ? ((req as any).files as any[]).map((file: any) => `/uploads/${file.filename}`) : [],
      });
      
      const ticket = await storage.createTicket(validatedData);
      res.json(ticket);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ ØªÛŒÚ©Øª" });
    }
  });

  app.put("/api/tickets/:id/reply", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { adminReply } = req.body;
      
      const ticket = await storage.updateTicket(id, {
        adminReply,
        adminReplyAt: new Date(),
        status: "read",
        lastResponseAt: new Date(),
      });
      
      if (!ticket) {
        return res.status(404).json({ message: "ØªÛŒÚ©Øª ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json(ticket);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ø³Ø® Ø¨Ù‡ ØªÛŒÚ©Øª" });
    }
  });

  app.delete("/api/tickets/:id", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const success = await storage.deleteTicket(id);
      
      if (!success) {
        return res.status(404).json({ message: "ØªÛŒÚ©Øª ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({ message: "ØªÛŒÚ©Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù ØªÛŒÚ©Øª" });
    }
  });

  // Subscription routes (Admin only)
  app.get("/api/subscriptions", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const subscriptions = await storage.getAllSubscriptions();
      res.json(subscriptions);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø´ØªØ±Ø§Ú© Ù‡Ø§" });
    }
  });

  app.post("/api/subscriptions", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const validatedData = insertSubscriptionSchema.parse(req.body);
      
      // Note: insertSubscriptionSchema already omits isDefault, so this check is not needed
      // but we keep it for safety
      
      // Force isDefault to false for all user-created subscriptions
      const safeData = { ...validatedData, isDefault: false };
      
      const subscription = await storage.createSubscription(safeData);
      res.json(subscription);
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú©:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú©" });
    }
  });

  app.put("/api/subscriptions/:id", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      // Get current subscription to check if it's the default free subscription
      const currentSubscription = await storage.getSubscription(id);
      if (!currentSubscription) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Prevent ANY modifications to default subscription (complete immutability)
      if (currentSubscription.isDefault) {
        return res.status(400).json({ 
          message: "Ø§Ù…Ú©Ø§Ù† ØªØºÛŒÛŒØ± Ø§Ø´ØªØ±Ø§Ú© Ù¾ÛŒØ´ ÙØ±Ø¶ Ø±Ø§ÛŒÚ¯Ø§Ù† ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯" 
        });
      } else {
        // Prevent setting isDefault=true on non-default subscriptions
        if (updates.isDefault === true) {
          return res.status(400).json({ 
            message: "ØªÙ†Ù‡Ø§ ÛŒÚ© Ø§Ø´ØªØ±Ø§Ú© Ù¾ÛŒØ´ ÙØ±Ø¶ Ù…ÛŒ ØªÙˆØ§Ù†Ø¯ ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ø¯" 
          });
        }
      }
      
      const subscription = await storage.updateSubscription(id, updates);
      if (!subscription) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json(subscription);
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú©:", error);
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú©" });
    }
  });

  app.delete("/api/subscriptions/:id", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Get subscription details first to check if it's the default free subscription
      const subscription = await storage.getSubscription(id);
      if (!subscription) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      // Prevent deletion of default subscription
      if (subscription.isDefault) {
        return res.status(400).json({ 
          message: "Ø§Ù…Ú©Ø§Ù† Ø­Ø°Ù Ø§Ø´ØªØ±Ø§Ú© Ù¾ÛŒØ´ ÙØ±Ø¶ Ø±Ø§ÛŒÚ¯Ø§Ù† ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯" 
        });
      }
      
      const success = await storage.deleteSubscription(id);
      
      if (!success) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json({ message: "Ø§Ø´ØªØ±Ø§Ú© Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      console.error("Error deleting subscription:", error);
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ø§Ø´ØªØ±Ø§Ú©" });
    }
  });

  // AI Token routes
  app.get("/api/ai-token", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const settings = await storage.getAiTokenSettings();
      res.json(settings || {});
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙˆÚ©Ù† Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ" });
    }
  });

  app.post("/api/ai-token", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const validatedData = insertAiTokenSettingsSchema.parse(req.body);
      const settings = await storage.updateAiTokenSettings(validatedData);
      
      // Ø¨Ø§Ø²Ø®ÙˆØ§Ù†ÛŒ Ø³Ø±ÙˆÛŒØ³ Gemini Ø¨Ø§ ØªÙˆÚ©Ù† Ø¬Ø¯ÛŒØ¯
      const { geminiService } = await import("./gemini-service");
      await geminiService.reinitialize();
      
      res.json(settings);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ ØªÙˆÚ©Ù† Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ" });
    }
  });

  // Product routes
  app.get("/api/products", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const products = await storage.getProductsByUser(req.user!.id);
      res.json(products);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù…Ø­ØµÙˆÙ„Ø§Øª" });
    }
  });

  app.post("/api/products", authenticateToken, upload.single("productImage"), async (req: AuthRequest, res) => {
    try {
      let imageData = null;
      
      // Ø§Ú¯Ø± ÙØ§ÛŒÙ„ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ Ø¢Ù† Ø±Ø§ Ø¨Ù‡ base64 ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      if ((req as any).file) {
        const fs = await import('fs');
        const fileBuffer = fs.readFileSync((req as any).file.path);
        const base64 = fileBuffer.toString('base64');
        const mimeType = (req as any).file.mimetype;
        imageData = `data:${mimeType};base64,${base64}`;
        
        // Ø­Ø°Ù ÙØ§ÛŒÙ„ Ù…ÙˆÙ‚Øª
        fs.unlinkSync((req as any).file.path);
      }
      
      const validatedData = insertProductSchema.parse({
        ...req.body,
        userId: req.user!.id,
        image: imageData,
        priceBeforeDiscount: parseFloat(req.body.priceBeforeDiscount),
        priceAfterDiscount: req.body.priceAfterDiscount ? parseFloat(req.body.priceAfterDiscount) : null,
        quantity: parseInt(req.body.quantity),
      });
      
      const product = await storage.createProduct(validatedData);
      res.json(product);
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ØµÙˆÙ„:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ù…Ø­ØµÙˆÙ„" });
    }
  });

  app.put("/api/products/:id", authenticateToken, upload.single("productImage"), async (req: AuthRequest, res) => {
    try {
      const { id } = req.params;
      let updates = { ...req.body };
      
      // Ø§Ú¯Ø± ÙØ§ÛŒÙ„ Ø¬Ø¯ÛŒØ¯ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ Ø¢Ù† Ø±Ø§ Ø¨Ù‡ base64 ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
      if ((req as any).file) {
        const fs = await import('fs');
        const fileBuffer = fs.readFileSync((req as any).file.path);
        const base64 = fileBuffer.toString('base64');
        const mimeType = (req as any).file.mimetype;
        updates.image = `data:${mimeType};base64,${base64}`;
        
        // Ø­Ø°Ù ÙØ§ÛŒÙ„ Ù…ÙˆÙ‚Øª
        fs.unlinkSync((req as any).file.path);
      }
      
      // Ensure user can only update their own products
      const product = await storage.getProduct(id);
      if (!product || (product.userId !== req.user!.id && req.user!.role !== "admin")) {
        return res.status(404).json({ message: "Ù…Ø­ØµÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const updatedProduct = await storage.updateProduct(id, updates);
      res.json(updatedProduct);
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø­ØµÙˆÙ„:", error);
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ù…Ø­ØµÙˆÙ„" });
    }
  });

  app.delete("/api/products/:id", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const { id } = req.params;
      
      // Ensure user can only delete their own products
      const product = await storage.getProduct(id);
      if (!product || (product.userId !== req.user!.id && req.user!.role !== "admin")) {
        return res.status(404).json({ message: "Ù…Ø­ØµÙˆÙ„ ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      const success = await storage.deleteProduct(id);
      res.json({ message: "Ù…Ø­ØµÙˆÙ„ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø­Ø°Ù Ø´Ø¯" });
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù…Ø­ØµÙˆÙ„" });
    }
  });

  // WhatsApp settings routes (Admin and Level 1 users)
  app.get("/api/whatsapp-settings", authenticateToken, requireAdminOrLevel1, async (req, res) => {
    try {
      const settings = await storage.getWhatsappSettings();
      res.json(settings || {});
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙˆØ§ØªØ³ Ø§Ù¾" });
    }
  });

  app.put("/api/whatsapp-settings", authenticateToken, requireAdminOrLevel1, async (req, res) => {
    try {
      const validatedData = insertWhatsappSettingsSchema.parse(req.body);
      const settings = await storage.updateWhatsappSettings(validatedData);
      res.json(settings);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª ÙˆØ§ØªØ³ Ø§Ù¾" });
    }
  });

  // Message routes (Admin and Level 1 users)
  app.get("/api/messages/sent", authenticateToken, requireAdminOrLevel1, async (req: AuthRequest, res) => {
    try {
      const messages = await storage.getSentMessagesByUser(req.user!.id);
      res.json(messages);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ÛŒ" });
    }
  });

  app.get("/api/messages/received", authenticateToken, requireAdminOrLevel1, async (req: AuthRequest, res) => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 7; // Ù¾ÛŒØ´â€ŒÙØ±Ø¶ 7 Ù¾ÛŒØ§Ù… Ø¯Ø± Ù‡Ø± ØµÙØ­Ù‡
      
      const result = await storage.getReceivedMessagesByUserPaginated(req.user!.id, page, limit);
      res.json(result);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÛŒ" });
    }
  });

  app.post("/api/messages/sent", authenticateToken, requireAdminOrLevel1, async (req: AuthRequest, res) => {
    try {
      const validatedData = insertSentMessageSchema.parse({
        ...req.body,
        userId: req.user!.id,
      });
      
      const message = await storage.createSentMessage(validatedData);
      res.json(message);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ù¾ÛŒØ§Ù… Ø§Ø±Ø³Ø§Ù„ÛŒ" });
    }
  });

  app.post("/api/messages/received", authenticateToken, requireAdminOrLevel1, async (req: AuthRequest, res) => {
    try {
      const validatedData = insertReceivedMessageSchema.parse({
        ...req.body,
        userId: req.user!.id,
      });
      
      const message = await storage.createReceivedMessage(validatedData);
      res.json(message);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ù¾ÛŒØ§Ù… Ø¯Ø±ÛŒØ§ÙØªÛŒ" });
    }
  });

  app.put("/api/messages/received/:id/read", authenticateToken, requireAdminOrLevel1, async (req: AuthRequest, res) => {
    try {
      const { id } = req.params;
      const message = await storage.updateReceivedMessageStatus(id, "Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡");
      
      if (!message) {
        return res.status(404).json({ message: "Ù¾ÛŒØ§Ù… ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json(message);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù¾ÛŒØ§Ù…" });
    }
  });

  // User Subscription routes
  // Get user's current subscription
  app.get("/api/user-subscriptions/me", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const userSubscription = await storage.getUserSubscription(req.user!.id);
      res.json(userSubscription);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Get all user subscriptions (Admin only)
  app.get("/api/user-subscriptions", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const userSubscriptions = await storage.getAllUserSubscriptions();
      res.json(userSubscriptions);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†" });
    }
  });

  // Create user subscription
  app.post("/api/user-subscriptions", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const validatedData = insertUserSubscriptionSchema.parse(req.body);
      const userSubscription = await storage.createUserSubscription(validatedData);
      res.json(userSubscription);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Ø¯Ø§Ø¯Ù‡ Ù‡Ø§ÛŒ ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª", errors: error.errors });
      }
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Update user subscription
  app.put("/api/user-subscriptions/:id", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const updates = req.body;
      
      const userSubscription = await storage.updateUserSubscription(id, updates);
      if (!userSubscription) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json(userSubscription);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø±" });
    }
  });

  // Update remaining days (for daily reduction)
  app.put("/api/user-subscriptions/:id/remaining-days", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { remainingDays } = req.body;
      
      if (typeof remainingDays !== 'number') {
        return res.status(400).json({ message: "ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡ Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ Ø¨Ø§Ø´Ø¯" });
      }
      
      const userSubscription = await storage.updateRemainingDays(id, remainingDays);
      if (!userSubscription) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø± ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }

      res.json(userSubscription);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±ÙˆØ²Ù‡Ø§ÛŒ Ø¨Ø§Ù‚ÛŒÙ…Ø§Ù†Ø¯Ù‡" });
    }
  });

  // Daily subscription reduction endpoint (for cron job)
  app.post("/api/user-subscriptions/daily-reduction", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const activeSubscriptions = await storage.getActiveUserSubscriptions();
      const updatedSubscriptions = [];
      
      for (const subscription of activeSubscriptions) {
        if (subscription.remainingDays > 0) {
          const newRemainingDays = subscription.remainingDays - 1;
          const updated = await storage.updateRemainingDays(subscription.id, newRemainingDays);
          if (updated) {
            updatedSubscriptions.push(updated);
          }
        }
      }
      
      res.json({
        message: `${updatedSubscriptions.length} Ø§Ø´ØªØ±Ø§Ú© Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯`,
        updatedSubscriptions
      });
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ú©Ø§Ù‡Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§:", error);
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ú©Ø§Ù‡Ø´ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§" });
    }
  });

  // Get active subscriptions
  app.get("/api/user-subscriptions/active", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const activeSubscriptions = await storage.getActiveUserSubscriptions();
      res.json(activeSubscriptions);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„" });
    }
  });

  // Get expired subscriptions  
  app.get("/api/user-subscriptions/expired", authenticateToken, requireAdmin, async (req, res) => {
    try {
      const expiredSubscriptions = await storage.getExpiredUserSubscriptions();
      res.json(expiredSubscriptions);
    } catch (error) {
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø§Ø´ØªØ±Ø§Ú©â€ŒÙ‡Ø§ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ" });
    }
  });

  // Subscribe to plan endpoint (for users)
  app.post("/api/user-subscriptions/subscribe", authenticateToken, async (req: AuthRequest, res) => {
    try {
      const { subscriptionId } = req.body;
      
      if (!subscriptionId) {
        return res.status(400).json({ message: "Ø´Ù†Ø§Ø³Ù‡ Ø§Ø´ØªØ±Ø§Ú© Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø§Ø³Øª" });
      }
      
      // Check if subscription exists
      const subscription = await storage.getSubscription(subscriptionId);
      if (!subscription) {
        return res.status(404).json({ message: "Ø§Ø´ØªØ±Ø§Ú© ÛŒØ§ÙØª Ù†Ø´Ø¯" });
      }
      
      if (!subscription.isActive) {
        return res.status(400).json({ message: "Ø§ÛŒÙ† Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª" });
      }
      
      // Check if user already has an active subscription
      const existingSubscription = await storage.getUserSubscription(req.user!.id);
      if (existingSubscription && existingSubscription.remainingDays > 0) {
        return res.status(400).json({ message: "Ø´Ù…Ø§ Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„ Ø¯Ø§Ø±ÛŒØ¯" });
      }
      
      // Calculate duration in days
      const durationInDays = subscription.duration === 'monthly' ? 30 : 365;
      
      // Create new user subscription
      const userSubscription = await storage.createUserSubscription({
        userId: req.user!.id,
        subscriptionId: subscriptionId,
        remainingDays: durationInDays,
        startDate: new Date(),
        endDate: new Date(Date.now() + durationInDays * 24 * 60 * 60 * 1000),
        status: "active",
      });
      
      res.json(userSubscription);
    } catch (error) {
      console.error("Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø´ØªØ±Ø§Ú©:", error);
      res.status(500).json({ message: "Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø§Ø´ØªØ±Ø§Ú©" });
    }
  });

  // Serve uploaded files
  app.use("/uploads", express.static(path.join(__dirname, "../uploads")));

  const httpServer = createServer(app);
  return httpServer;
}
